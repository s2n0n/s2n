"""
s2n-xss: XSS Vulnerability Scanner
Developer-friendly XSS detection optimized for Korean web applications

Features:
- ✨ Supports 3 types of XSS: Reflected, Stored, DOM-based
- ✨ Interactive scanning mode
- ✨ Context-aware payload selection
- ✨ Korean encoding issue detection (UTF-8, EUC-KR, fullwidth chars)
- ✨ Developer-friendly detailed reports with fix recommendations
- ✨ Lightweight and CI/CD friendly
- ✨ Automatic input point detection (no need to specify parameters manually)
- ✨ HTML form auto-parsing for DVWA and other web applications
- ✨ POST/GET method auto-detection
"""

import json
import requests
import re
from urllib.parse import urlencode, urlparse, parse_qs, urljoin
from typing import Dict, List, Tuple, Optional
from html.parser import HTMLParser
import time

TOKEN_KEYWORDS = ("token", "csrf", "nonce")


class FormParser(HTMLParser):
    """
    자동 입력 지점 탐지를 위해 HTML에서 폼과 입력 필드를 추출하는 파서
    """

    def __init__(self):
        super().__init__()
        self.forms = []
        self.current_form = None

    def handle_starttag(self, tag, attrs):
        attrs_dict = dict(attrs)

        if tag == "form":
            self.current_form = {
                "action": attrs_dict.get("action", ""),
                "method": attrs_dict.get("method", "GET").upper(),
                "inputs": [],
            }

        elif tag in ["input", "textarea", "select"] and self.current_form is not None:
            input_field = {
                "type": attrs_dict.get("type", "text"),
                "name": attrs_dict.get("name", ""),
                "value": attrs_dict.get("value", ""),
                "tag": tag,
            }

            if input_field["name"]:
                self.current_form["inputs"].append(input_field)

    def handle_endtag(self, tag):
        if tag == "form" and self.current_form is not None:
            self.forms.append(self.current_form)
            self.current_form = None


class InputPointDetector:
    """
    웹 페이지에서 입력 지점을 자동으로 탐지
    URL 파라미터, HTML 폼을 자동으로 찾아냄
    """

    def __init__(self, session: requests.Session):
        self.session = session

    def detect_input_points(self, url: str) -> List[Dict]:
        """
        URL에서 모든 입력 지점을 탐지

        Returns:
            [{url, method, params, source}, ...]
        """
        input_points = []

        # 1. URL 파라미터 추출
        parsed = urlparse(url)
        url_params = parse_qs(parsed.query)
        if url_params:
            params = {
                k: v[0] if isinstance(v, list) else v for k, v in url_params.items()
            }
            input_points.append(
                {
                    "url": url.split("?")[0],
                    "method": "GET",
                    "params": params,
                    "source": "url",
                }
            )

        # 2. HTML 폼 파싱
        try:
            response = self.session.get(url, timeout=10)
            if response.status_code == 200:
                parser = FormParser()
                parser.feed(response.text)

                for form in parser.forms:
                    if form["inputs"]:
                        action_url = (
                            urljoin(url, form["action"]) if form["action"] else url
                        )

                        params = {}
                        for inp in form["inputs"]:
                            # submit 버튼은 제외
                            input_type = inp["type"].lower()
                            name = inp["name"]
                            if not name:
                                continue

                            if input_type in ["submit", "button"]:
                                params[name] = inp["value"] if inp["value"] else name
                                continue

                            params[name] = inp["value"] if inp["value"] else "test"

                            # ✨ Preserve hidden inputs like user_token
                            if input_type == "hidden":
                                params[name] = inp["value"]

                        if params:
                            input_points.append(
                                {
                                    "url": action_url,
                                    "method": form["method"],
                                    "params": params,
                                    "source": "form",
                                }
                            )
        except Exception as e:
            print(f"  [!] Error detecting forms: {e}")

        return input_points


class DOMXSSDetector:
    """
    DOM-based XSS 탐지기
    JavaScript 코드에서 Source와 Sink를 찾아 DOM XSS 탐지
    """

    # 위험한 JavaScript Sink 패턴
    DANGEROUS_SINKS = [
        r"document\.write\s*\(",
        r"document\.writeln\s*\(",
        r"\.innerHTML\s*=",
        r"\.outerHTML\s*=",
        r"eval\s*\(",
        r"setTimeout\s*\(",
        r"setInterval\s*\(",
        r"Function\s*\(",
        r"location\s*=",
        r"location\.href\s*=",
        r"location\.replace\s*\(",
        r"location\.assign\s*\(",
    ]

    # 위험한 JavaScript Source 패턴
    DANGEROUS_SOURCES = [
        r"location\.hash",
        r"location\.search",
        r"document\.URL",
        r"document\.documentURI",
        r"document\.referrer",
        r"window\.name",
    ]

    def detect_dom_xss(self, html: str) -> List[Tuple[str, str]]:
        """
        JavaScript 코드 분석하여 DOM XSS 취약점 탐지

        Returns:
            [(source, sink), ...] 튜플 리스트
        """
        vulnerabilities = []

        # <script> 태그에서 JavaScript 추출
        script_pattern = r"<script[^>]*>(.*?)</script>"
        scripts = re.findall(script_pattern, html, re.DOTALL | re.IGNORECASE)

        for script_content in scripts:
            found_source = None
            found_sink = None

            # Source 찾기
            for source_pattern in self.DANGEROUS_SOURCES:
                match = re.search(source_pattern, script_content)
                if match:
                    found_source = match.group()
                    break

            # Sink 찾기
            for sink_pattern in self.DANGEROUS_SINKS:
                match = re.search(sink_pattern, script_content)
                if match:
                    found_sink = match.group()
                    break

            # Source와 Sink 모두 있으면 취약점
            if found_source and found_sink:
                vulnerabilities.append((found_source, found_sink))

        return vulnerabilities


class StoredXSSDetector:
    """
    Stored XSS 탐지기
    페이로드를 전송 후 저장 여부 확인
    """

    @staticmethod
    def _update_tokens_from_html(html: str, data: Dict[str, str]) -> None:
        parser = FormParser()
        parser.feed(html)
        for form in parser.forms:
            for inp in form["inputs"]:
                name = inp["name"]
                if not name:
                    continue
                lower = name.lower()
                if any(keyword in lower for keyword in TOKEN_KEYWORDS):
                    data[name] = inp.get("value", "")

    def __init__(self, session: requests.Session):
        self.session = session

    def test_stored_xss(
        self, url: str, form_data: Dict, method: str
    ) -> Tuple[bool, str]:
        """
        저장형 XSS 테스트 (개선판)

        동작:
        1) 페이지에서 user_token(hidden) 같은 CSRF 토큰을 자동으로 추출하여 포함
        2) 모든 텍스트/메시지 필드에 고유 페이로드 삽입 후 POST/GET 전송
        3) 페이지를 재요청하여 페이로드가 저장되어 그대로 출력되는지 검사

        Returns:
            (is_vulnerable, payload_used)
        """
        # 고유 식별자 포함 페이로드
        unique_id = f"s2n_stored_{int(time.time())}"
        payload = f"<script>alert('{unique_id}')</script>"

        # 복사해서 테스트 데이터 준비 (원본 변경 방지)
        test_data = form_data.copy() if form_data else {}

        # 1) 페이지에서 CSRF 토큰(user_token 등) 최신 값으로 갱신
        try:
            resp = self.session.get(url, timeout=self.timeout)
            resp.encoding = resp.apparent_encoding
            self._update_tokens_from_html(resp.text, test_data)
        except Exception:
            # 실패하더라도 기존 값 유지
            pass

        # 2) 모든 텍스트계 입력 필드에 페이로드 삽입
        for key in list(test_data.keys()):
            lower = key.lower()
            if lower in ["submit", "btnsign"] or any(
                token in lower for token in TOKEN_KEYWORDS
            ):
                continue
            test_data[key] = payload

        try:
            # 전송
            if method.upper() == "POST":
                post_resp = self.session.post(url, data=test_data, timeout=self.timeout)
                post_resp.encoding = post_resp.apparent_encoding
                self._update_tokens_from_html(post_resp.text, test_data)
            else:
                get_resp = self.session.get(url, params=test_data, timeout=self.timeout)
                get_resp.encoding = get_resp.apparent_encoding

            # 짧은 대기 후 재조회하여 저장 여부 확인
            time.sleep(0.8)
            response = self.session.get(url, timeout=self.timeout)
            response.encoding = response.apparent_encoding
            self._update_tokens_from_html(response.text, test_data)

            # 페이로드가 인코딩 없이 그대로 있는지 또는 고유 ID가 보이는지 확인
            if payload in response.text or unique_id in response.text:
                return True, payload

            # 또한 HTML-escaped 형태도 검사
            import html

            escaped = html.escape(payload)
            if escaped in response.text:
                return True, payload

            return False, payload

        except Exception:
            return False, payload


# ============================================================
# ✨ NEW: Payload Categorizer (페이로드 분류기)
# ============================================================
class PayloadCategorizer:
    """
    페이로드를 카테고리별로 분류하여 더 나은 리포트 생성
    """

    @staticmethod
    def categorize_payload(payload: str) -> Dict[str, str]:
        """
        페이로드를 카테고리로 분류

        Returns:
            {
                'category': 'basic_script' | 'event_handler' | 'encoding' | ...,
                'category_ko': '기본 스크립트' | '이벤트 핸들러' | ...,
                'description': '설명'
            }
        """
        payload_lower = payload.lower()

        # 1. 기본 스크립트 태그
        if (
            "<script>" in payload_lower
            and "fromcharcode" not in payload_lower
            and "atob" not in payload_lower
        ):
            return {
                "category": "basic_script",
                "category_ko": "기본 스크립트 태그",
                "description": "Standard <script> tag injection",
            }

        # 2. 이벤트 핸들러
        if any(
            event in payload_lower
            for event in [
                "onerror",
                "onload",
                "onfocus",
                "onclick",
                "onmouseover",
                "ontoggle",
            ]
        ):
            return {
                "category": "event_handler",
                "category_ko": "이벤트 핸들러",
                "description": "HTML event handler exploitation",
            }

        # 3. 인코딩 우회
        if any(enc in payload for enc in ["%", "\\u", "\\x", "&#", "&lt;", "&gt;"]):
            return {
                "category": "encoding_bypass",
                "category_ko": "인코딩 우회",
                "description": "Encoded payload to bypass filters",
            }

        # 4. 난독화
        if (
            "fromcharcode" in payload_lower
            or "atob" in payload_lower
            or "eval" in payload_lower
        ):
            return {
                "category": "obfuscation",
                "category_ko": "난독화",
                "description": "Obfuscated JavaScript code",
            }

        # 5. 공백 우회
        if any(char in payload for char in ["/", "\t", "\n"]) and "<" in payload:
            return {
                "category": "whitespace_bypass",
                "category_ko": "공백 문자 우회",
                "description": "Alternative whitespace characters",
            }

        # 6. 한글/인코딩 특화
        if any(
            pattern in payload
            for pattern in ["EUC-KR", "테스트", "한글", "가나다", "%C5%", "%D7%"]
        ):
            return {
                "category": "korean_encoding",
                "category_ko": "한글 인코딩",
                "description": "Korean encoding specific payload",
            }

        # 7. 대소문자 혼합
        if "<script>" not in payload_lower and "<script" in payload_lower:
            return {
                "category": "case_variation",
                "category_ko": "대소문자 변형",
                "description": "Mixed case to bypass filters",
            }

        # 8. HTML 주석 우회
        if "<!--" in payload or "//-->" in payload:
            return {
                "category": "comment_bypass",
                "category_ko": "HTML 주석 우회",
                "description": "HTML comment manipulation",
            }

        # 기타
        return {
            "category": "other",
            "category_ko": "기타",
            "description": "Other XSS technique",
        }


# ============================================================
# S2NXSSPlugin 클래스 (개선된 버전)
# ============================================================


class S2NXSSPlugin:
    """
    s2n-xss 코어 엔진

    ✨ IMPROVED v2.1:
    - 동일 위치 취약점 그룹핑
    - 페이로드 카테고리 분류
    - 향상된 리포트 구조
    """

    def __init__(
        self,
        payloads_path: str,
        cookies: Optional[Dict] = None,
        timeout: int = 10,
        auto_detect: bool = True,
    ):
        """
        Args:
            payloads_path: 페이로드 JSON 파일 경로
            cookies: 세션 쿠키 (선택)
            timeout: 요청 타임아웃 (초)
            auto_detect: 자동 입력 지점 탐지 활성화
        """
        self.timeout = timeout
        self.auto_detect = auto_detect

        # ✨ IMPROVED: 결과 저장 구조 변경 (기존: 단순 리스트 -> 새로운: 그룹핑된 딕셔너리)
        self.results = []  # 기존 호환성을 위해 유지
        self.grouped_vulnerabilities = {}  # ✨ NEW: 위치별로 그룹핑된 취약점
        self.total_payload_tests = 0

        self.session = requests.Session()

        if cookies:
            # Apply cookies (e.g., PHPSESSID, security level)
            self.session.cookies.update(cookies)

            # Ensure DVWA default security=low if not specified
            if "security" not in self.session.cookies:
                self.session.cookies.set("security", "low")

        # 사용자 에이전트 설정
        self.session.headers.update({"User-Agent": "s2n-xss/2.1 (Security Scanner)"})

        # 페이로드 로드
        with open(payloads_path, "r", encoding="utf-8") as f:
            self.payloads_data = json.load(f)

        # 탐지기 초기화
        self.input_detector = InputPointDetector(self.session)
        self.dom_detector = DOMXSSDetector()
        self.stored_detector = StoredXSSDetector(self.session)

        print(
            f"[+] Loaded {self.payloads_data['metadata']['total_payloads']} payloads from {payloads_path}"
        )

    def _update_tokens_from_html(self, html: str, params: Dict[str, str]) -> None:
        """
        폼 HTML에서 token/csrf/nonce 필드 값을 추출하여 params를 최신 상태로 유지
        """
        parser = FormParser()
        parser.feed(html)
        for form in parser.forms:
            for inp in form["inputs"]:
                name = inp["name"]
                if not name:
                    continue
                lower = name.lower()
                if any(keyword in lower for keyword in TOKEN_KEYWORDS):
                    params[name] = inp.get("value", "")

    def select_payloads(self, intensity: int = 2) -> List[str]:
        """
        스캔 강도에 따라 페이로드 선택

        Args:
            intensity: 1(Basic) ~ 3(Aggressive)

        Returns:
            선택된 페이로드 리스트
        """
        payloads = []

        if intensity >= 1:
            # 기본 페이로드
            payloads.extend(self.payloads_data["payloads"]["html_context"]["basic"][:3])

        if intensity >= 2:
            # 중급 페이로드 추가
            payloads.extend(self.payloads_data["payloads"]["html_context"]["basic"][3:])
            payloads.extend(
                self.payloads_data["payloads"]["html_context"]["korean_specific"]
            )
            payloads.extend(
                self.payloads_data["payloads"]["attribute_context"]["double_quote"][:2]
            )
            payloads.extend(self.payloads_data["filter_bypass"]["obfuscation"][:3])
            payloads.extend(self.payloads_data["filter_bypass"]["space_bypass"])
            payloads.extend(self.payloads_data["filter_bypass"]["comment_bypass"])
            payloads.extend(
                self.payloads_data["korean_encoding_specific"]["euc_kr_bypass"]
            )

        if intensity >= 3:
            # 고급 페이로드 추가
            payloads.extend(self.payloads_data["filter_bypass"]["encoding"])
            payloads.extend(
                self.payloads_data["payloads"]["attribute_context"]["single_quote"]
            )
            payloads.extend(
                self.payloads_data["payloads"]["attribute_context"]["no_quote"]
            )
            payloads.extend(
                self.payloads_data["korean_encoding_specific"]["fullwidth_chars"]
            )

        return payloads

    def test_payload(
        self, url: str, params: Dict, payload: str, method: str = "GET"
    ) -> Tuple[bool, str]:
        """
        단일 페이로드 테스트

        Returns:
            (is_vulnerable, detected_context)
        """
        test_params = params.copy()

        try:
            if method.upper() == "POST":
                response = self.session.post(
                    url, data=test_params, timeout=self.timeout
                )
                # Ensure correct encoding detection
                response.encoding = response.apparent_encoding
            else:
                response = self.session.get(
                    url, params=test_params, timeout=self.timeout
                )
                # Ensure correct encoding detection
                response.encoding = response.apparent_encoding

            # 응답에서 페이로드 확인
            import html

            escaped = html.escape(payload)
            # Combine redirect chain and final page for more accurate detection
            final_html = response.text
            if response.history:
                for hist in response.history:
                    hist.encoding = hist.apparent_encoding
                    final_html += hist.text

            # POST 실행 후 토큰이 갱신되는 경우를 대비해 params 업데이트
            self._update_tokens_from_html(final_html, params)

            if payload in final_html or escaped in final_html:
                # 컨텍스트 감지
                context = self.detect_context(final_html, payload)
                return True, context

            return False, ""

        except Exception as e:
            return False, ""

    def detect_context(self, html: str, payload: str) -> str:
        """
        페이로드가 삽입된 컨텍스트 감지

        Returns:
            'html', 'attribute', 'javascript', 'korean_euc_kr' 등
        """
        # 한글 인코딩 체크
        if any(
            korean in payload
            for korean in ["한글", "테스트", "EUC-KR", "가나다", "%C5%", "%D7%"]
        ):
            return "korean_euc_kr"

        # 속성 컨텍스트
        if re.search(rf'<\w+[^>]*\s+\w+\s*=\s*["\']?[^"\']*{re.escape(payload)}', html):
            return "attribute"

        # JavaScript 컨텍스트
        if re.search(
            rf"<script[^>]*>.*{re.escape(payload)}.*</script>", html, re.DOTALL
        ):
            return "javascript"

        # HTML 컨텍스트
        return "html"

    def scan(
        self,
        target_url: str,
        params: Optional[Dict] = None,
        method: str = "GET",
        intensity: int = 2,
    ) -> List[Dict]:
        """
        XSS 스캔 실행

        Args:
            target_url: 대상 URL
            params: 파라미터 (자동 탐지 시 None)
            method: HTTP 메소드
            intensity: 스캔 강도 (1~3)

        Returns:
            취약점 리스트
        """
        print(f"\n[*] Target: {target_url}")
        print(f"[*] Mode: {'AUTO' if self.auto_detect else 'MANUAL'}")
        print(f"[*] Intensity: {intensity}/3")

        # 카운터 초기화
        self.total_payload_tests = 0

        # 입력 지점 탐지
        if self.auto_detect:
            print("\n[*] Detecting input points...")
            input_points = self.input_detector.detect_input_points(target_url)
            print(f"[+] Found {len(input_points)} input point(s)")
        else:
            if not params:
                parsed = urlparse(target_url)
                params = dict(parse_qs(parsed.query))
                params = {
                    k: v[0] if isinstance(v, list) else v for k, v in params.items()
                }
                target_url = target_url.split("?")[0]

            input_points = [
                {
                    "url": target_url,
                    "method": method,
                    "params": params,
                    "source": "manual",
                }
            ]

        if not input_points:
            print("[!] No input points found. Exiting.")
            return []

        # 페이로드 선택
        payloads = self.select_payloads(intensity)
        print(f"[*] Testing {len(payloads)} payload(s)...\n")

        # 각 입력 지점 테스트
        for idx, point in enumerate(input_points, 1):
            url = point["url"]
            method = point["method"]
            params = point["params"]
            source = point["source"]

            print(f"[{idx}/{len(input_points)}] Testing: {url}")
            print(f"    Method: {method}")
            print(f"    Parameters: {list(params.keys())}")
            print(f"    Source: {source}")

            # Reflected XSS 테스트
            for param_name in list(params.keys()):
                lower_param = param_name.lower()
                if lower_param in ["submit", "btnsign"] or any(
                    keyword in lower_param for keyword in TOKEN_KEYWORDS
                ):
                    continue

                print(f"\n  [*] Testing parameter: {param_name}")

                # ✨ IMPROVED: 위치별 키 생성
                location_key = f"{url}|{param_name}|{method}"

                # ✨ IMPROVED: 그룹핑된 취약점 구조 초기화
                if location_key not in self.grouped_vulnerabilities:
                    self.grouped_vulnerabilities[location_key] = {
                        "location": {
                            "url": url,
                            "parameter": param_name,
                            "method": method,
                        },
                        "successful_payloads": [],
                        "xss_type": "Reflected XSS",
                        "first_detected": time.strftime("%Y-%m-%d %H:%M:%S"),
                    }

                successful_count = 0
                for payload in payloads:
                    self.total_payload_tests += 1
                    # 전체 params 복사 후, 현재 테스트 중인 param만 교체
                    test_params = dict(
                        params
                    )  # <-- preserve all original fields (including user_token)
                    test_params[param_name] = payload

                    is_vulnerable, context = self.test_payload(
                        url, test_params, payload, method
                    )

                    if is_vulnerable:
                        successful_count += 1

                        # ✨ IMPROVED: 페이로드 카테고리 분류
                        category_info = PayloadCategorizer.categorize_payload(payload)

                        # ✨ IMPROVED: 그룹핑된 구조에 페이로드 추가
                        payload_info = {
                            "payload": payload,
                            "context": context,
                            "category": category_info["category"],
                            "category_ko": category_info["category_ko"],
                            "description": category_info["description"],
                            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                        }
                        self.grouped_vulnerabilities[location_key][
                            "successful_payloads"
                        ].append(payload_info)

                print(f"  [+] {successful_count}/{len(payloads)} payloads successful")

            # Stored XSS 테스트
            if method.upper() == "POST" and source == "form":
                print(f"\n  [*] Testing for Stored XSS...")
                self.total_payload_tests += 1
                is_stored, stored_payload = self.stored_detector.test_stored_xss(
                    url, params, method
                )
                if is_stored:
                    print(f"  [!] Stored XSS detected!")

                    # Stored XSS도 그룹핑
                    location_key = f"{url}|stored|{method}"
                    matching_keys = [
                        key
                        for key, vuln in self.grouped_vulnerabilities.items()
                        if vuln["location"]["url"] == url
                    ]

                    # 기존 성공 페이로드를 저장형으로 전환
                    aggregated_payloads = []
                    for key in matching_keys:
                        aggregated_payloads.extend(
                            self.grouped_vulnerabilities[key]["successful_payloads"]
                        )

                    for payload_entry in aggregated_payloads:
                        payload_entry["context"] = "stored"

                    # 매핑에서 중복 키 제거 (stored 키 제외)
                    for key in matching_keys:
                        if key != location_key:
                            self.grouped_vulnerabilities.pop(key, None)

                    stored_group = self.grouped_vulnerabilities.get(location_key)
                    if not stored_group:
                        stored_group = {
                            "location": {
                                "url": url,
                                "parameter": "multiple_fields",
                                "method": method,
                            },
                            "successful_payloads": [],
                            "xss_type": "Stored XSS",
                            "first_detected": time.strftime("%Y-%m-%d %H:%M:%S"),
                        }
                        self.grouped_vulnerabilities[location_key] = stored_group
                    else:
                        stored_group["location"]["parameter"] = "multiple_fields"
                        stored_group["xss_type"] = "Stored XSS"

                    category_info = PayloadCategorizer.categorize_payload(
                        stored_payload
                    )
                    payload_info = {
                        "payload": stored_payload,
                        "context": "stored",
                        "category": category_info["category"],
                        "category_ko": category_info["category_ko"],
                        "description": category_info["description"],
                        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    }
                    aggregated_payloads.append(payload_info)
                    stored_group["successful_payloads"] = aggregated_payloads

            # DOM XSS 탐지
            try:
                response = self.session.get(url, timeout=self.timeout)
                dom_vulns = self.dom_detector.detect_dom_xss(response.text)
                if dom_vulns:
                    print(f"\n  [!] Potential DOM XSS detected!")
                    print(f"      Sources & Sinks found: {len(dom_vulns)}")

                    dom_key = f"{url}|dom|GET"
                    dom_group = self.grouped_vulnerabilities.get(dom_key)
                    if not dom_group:
                        dom_group = {
                            "location": {
                                "url": url,
                                "parameter": "dom_source",
                                "method": "GET",
                            },
                            "successful_payloads": [],
                            "xss_type": "DOM XSS",
                            "first_detected": time.strftime("%Y-%m-%d %H:%M:%S"),
                        }
                        self.grouped_vulnerabilities[dom_key] = dom_group

                    existing_dom = {
                        entry["payload"] for entry in dom_group["successful_payloads"]
                    }

                    for source, sink in dom_vulns:
                        payload_repr = f"{source} -> {sink}"
                        if payload_repr in existing_dom:
                            continue
                        dom_group["successful_payloads"].append(
                            {
                                "payload": payload_repr,
                                "context": "dom",
                                "category": "dom_analysis",
                                "category_ko": "DOM 분석",
                                "description": f"Source: {source}, Sink: {sink}",
                                "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                            }
                        )
                        existing_dom.add(payload_repr)
            except:
                pass

        return self._rebuild_results()

    def _rebuild_results(self) -> List[Dict]:
        """
        그룹핑된 취약점 정보를 기반으로 고유한 결과 리스트를 생성
        """
        rebuilt_results = []

        for vuln in self.grouped_vulnerabilities.values():
            location = vuln["location"]
            method = location.get("method", "GET")
            url = location.get("url", "")
            parameter = location.get("parameter", "")

            payload_example = ""
            context_detected = ""
            if vuln["successful_payloads"]:
                payload_example = vuln["successful_payloads"][0].get("payload", "")
                context_detected = vuln["successful_payloads"][0].get("context", "")

            injection_point = f"{method} {url}"
            if parameter and parameter not in ["multiple_fields", "dom_source"]:
                if method.upper() == "GET":
                    injection_point += (
                        f"?{parameter}={payload_example}"
                        if payload_example
                        else f"?{parameter}=<payload>"
                    )
                else:
                    injection_point += f" ({parameter})"
            elif parameter == "multiple_fields":
                injection_point += " (multiple fields)"
            elif parameter == "dom_source":
                injection_point += "#<dom>"

            human_parameter = parameter or "N/A"
            human_parameter_ko = parameter or "N/A"
            if parameter == "multiple_fields":
                human_parameter = "multiple fields"
                human_parameter_ko = "여러 입력 필드"
            elif parameter == "dom_source":
                human_parameter = "DOM context"
                human_parameter_ko = "DOM 컨텍스트"

            rebuilt_results.append(
                {
                    "scanner": "s2n-xss",
                    "vulnerability_type": "Cross-Site Scripting (XSS)",
                    "vulnerability_type_ko": "크로스 사이트 스크립팅 (XSS)",
                    "severity": "HIGH",
                    "cvss_score": 7.5,
                    "location": location,
                    "evidence": {
                        "payload_used": payload_example,
                        "context_detected": context_detected
                        or vuln["xss_type"].lower(),
                        "injection_point": injection_point,
                    },
                    "description": {
                        "korean": f"'{human_parameter_ko}' 위치에서 {vuln['xss_type']} 취약점이 확인되었습니다.",
                        "english": f"{vuln['xss_type']} detected at {human_parameter}.",
                    },
                    "impact": {
                        "korean": [
                            "사용자 세션 쿠키 탈취",
                            "사용자 계정 권한으로 악의적 행위 수행",
                            "피싱 페이지로 리다이렉트",
                            "사용자 입력 정보 탈취",
                        ],
                        "english": [
                            "Session cookie theft",
                            "Unauthorized actions with user privileges",
                            "Redirection to phishing pages",
                            "User input data exfiltration",
                        ],
                    },
                    "fix_recommendation": {
                        "korean": "모든 사용자 입력값을 검증하고, 출력 시 HTML 이스케이프 처리를 적용하세요.",
                        "english": "Validate all user inputs and apply HTML escaping on output.",
                    },
                    "references": [
                        "https://owasp.org/www-community/attacks/xss/",
                        "https://portswigger.net/web-security/cross-site-scripting",
                        "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html",
                    ],
                    "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
                    "xss_type": vuln["xss_type"],
                }
            )

        self.results = rebuilt_results
        return rebuilt_results

    # ============================================================
    # ✨ IMPROVED: 새로운 리포트 생성 메소드
    # ============================================================
    def export_report(self, output_path: str = None):
        """
        ✨ IMPROVED: 그룹핑된 구조의 리포트 생성

        변경사항:
        1. 동일 위치 취약점을 하나로 통합
        2. 페이로드 카테고리별 분류
        3. 향상된 수정 가이드
        4. 페이로드 통계 추가

        Args:
            output_path: 리포트 저장 경로 (None이면 현재 디렉토리에 자동 생성)
        """

        # ✨ NEW: output_path가 None이면 현재 디렉토리에 타임스탬프 포함 파일명 생성
        if output_path is None:
            script_dir = os.path.dirname(os.path.abspath(__file__))
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            output_path = os.path.join(script_dir, f"s2n_xss_report_{timestamp}.json")

        # 최신 결과 동기화
        self._rebuild_results()

        # ✨ NEW: 페이로드 통계 생성
        successful_payloads_total = sum(
            len(v["successful_payloads"]) for v in self.grouped_vulnerabilities.values()
        )

        # ✨ NEW: 카테고리별 통계
        category_stats = {}
        for vuln in self.grouped_vulnerabilities.values():
            for payload in vuln["successful_payloads"]:
                category = payload["category_ko"]
                category_stats[category] = category_stats.get(category, 0) + 1

        # ✨ NEW: 취약점을 리스트로 변환 (향상된 구조)
        vulnerabilities_list = []
        for location_key, vuln_data in self.grouped_vulnerabilities.items():

            # ✨ NEW: 페이로드를 카테고리별로 그룹핑
            payloads_by_category = {}
            for payload_info in vuln_data["successful_payloads"]:
                category = payload_info["category_ko"]
                if category not in payloads_by_category:
                    payloads_by_category[category] = []
                payloads_by_category[category].append(
                    {
                        "payload": payload_info["payload"],
                        "context": payload_info["context"],
                        "description": payload_info["description"],
                    }
                )

            # ✨ NEW: 향상된 취약점 구조
            enhanced_vuln = {
                "vulnerability_id": f"XSS-{len(vulnerabilities_list) + 1:03d}",
                "scanner": "s2n-xss",
                "version": "2.1-improved",
                "vulnerability_type": "Cross-Site Scripting (XSS)",
                "vulnerability_type_ko": "크로스 사이트 스크립팅 (XSS)",
                "severity": "HIGH",
                "cvss_score": 7.5,
                "xss_type": vuln_data["xss_type"],
                # 위치 정보
                "location": vuln_data["location"],
                # ✨ NEW: 페이로드 요약
                "payload_summary": {
                    "total_successful": len(vuln_data["successful_payloads"]),
                    "categories": list(payloads_by_category.keys()),
                    "first_detected": vuln_data["first_detected"],
                },
                # ✨ NEW: 카테고리별 페이로드
                "payloads_by_category": payloads_by_category,
                # ✨ NEW: 전체 페이로드 목록 (간단한 형태)
                "all_payloads": [
                    p["payload"] for p in vuln_data["successful_payloads"]
                ],
                # 기존 정보 (한 번만)
                "description": {
                    "korean": f"'{vuln_data['location']['parameter']}' 파라미터에서 XSS 취약점이 발견되었습니다. {len(vuln_data['successful_payloads'])}개의 서로 다른 페이로드가 모두 성공했으며, 이는 입력 검증이 전혀 없음을 의미합니다.",
                    "english": f"XSS vulnerability found in parameter '{vuln_data['location']['parameter']}'. All {len(vuln_data['successful_payloads'])} different payloads succeeded, indicating no input validation.",
                },
                "impact": {
                    "korean": [
                        "사용자 세션 쿠키 탈취",
                        "사용자 계정 권한으로 악의적 행위 수행",
                        "피싱 페이지로 리다이렉트",
                        "사용자 입력 정보 탈취",
                    ],
                    "english": [
                        "Session cookie theft",
                        "Unauthorized actions with user privileges",
                        "Redirection to phishing pages",
                        "User input data exfiltration",
                    ],
                },
                # ✨ NEW: 향상된 수정 가이드
                "fix_recommendation": {
                    "priority": "CRITICAL",
                    "estimated_fix_time": "30 minutes",
                    "complexity": "LOW",
                    "summary": {
                        "korean": "모든 사용자 입력값을 출력하기 전 HTML 이스케이프 처리가 필요합니다. 또한 Content Security Policy (CSP) 헤더를 설정하여 XSS 공격을 방어하세요.",
                        "english": "All user inputs must be HTML-escaped before output. Additionally, implement Content Security Policy (CSP) headers.",
                    },
                    # ✨ NEW: 단계별 수정 가이드
                    "step_by_step": [
                        {
                            "step": 1,
                            "action": "취약한 코드 찾기",
                            "details": f"파라미터 '{vuln_data['location']['parameter']}'를 처리하는 코드 위치 확인",
                        },
                        {
                            "step": 2,
                            "action": "HTML 이스케이프 적용",
                            "details": "출력 전 특수문자(<, >, \", ', &) 이스케이프 처리",
                        },
                        {
                            "step": 3,
                            "action": "CSP 헤더 설정",
                            "details": "Content-Security-Policy 헤더로 인라인 스크립트 차단",
                        },
                        {
                            "step": 4,
                            "action": "테스트 및 검증",
                            "details": f"URL: {vuln_data['location']['url']}?{vuln_data['location']['parameter']}=<script>alert(1)</script> 테스트",
                        },
                    ],
                    # 코드 예시
                    "code_examples": {
                        "php": {
                            "vulnerable": f"echo $_GET['{vuln_data['location']['parameter']}'];  // VULNERABLE",
                            "fixed": f"echo htmlspecialchars($_GET['{vuln_data['location']['parameter']}'], ENT_QUOTES, 'UTF-8');  // SECURE",
                        },
                        "python": {
                            "vulnerable": "return user_input  # VULNERABLE",
                            "fixed": "from html import escape\nreturn escape(user_input)  # SECURE",
                        },
                        "javascript": {
                            "vulnerable": "element.innerHTML = userInput;  // VULNERABLE",
                            "fixed": "element.textContent = userInput;  // SECURE",
                        },
                        "csp_header": "Content-Security-Policy: default-src 'self'; script-src 'self'",
                    },
                },
                "references": [
                    "https://owasp.org/www-community/attacks/xss/",
                    "https://portswigger.net/web-security/cross-site-scripting",
                    "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html",
                    "https://developer.mozilla.org/ko/docs/Web/Security/Types_of_attacks#%ED%81%AC%EB%A1%9C%EC%8A%A4_%EC%82%AC%EC%9D%B4%ED%8A%B8_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85_xss",
                ],
            }

            vulnerabilities_list.append(enhanced_vuln)

        # ✨ NEW: XSS 타입별 분류
        xss_type_breakdown = {}
        for vuln in vulnerabilities_list:
            xss_type = vuln["xss_type"]
            xss_type_breakdown[xss_type] = xss_type_breakdown.get(xss_type, 0) + 1

        total_tests_attempted = self.total_payload_tests or successful_payloads_total

        # ✨ IMPROVED: 향상된 리포트 구조
        report = {
            "scanner": "s2n-xss",
            "version": "2.1-improved",
            "report_format": "grouped",
            # ✨ NEW: 향상된 스캔 요약
            "scan_summary": {
                "unique_vulnerabilities": len(vulnerabilities_list),
                "total_payloads_tested": total_tests_attempted,
                "successful_payloads": successful_payloads_total,
                "success_rate": (
                    f"{(successful_payloads_total / total_tests_attempted * 100):.1f}%"
                    if total_tests_attempted
                    else "0%"
                ),
                "severity_breakdown": {
                    "CRITICAL": 0,
                    "HIGH": len(vulnerabilities_list),
                    "MEDIUM": 0,
                    "LOW": 0,
                },
                "xss_type_breakdown": xss_type_breakdown,
                # ✨ NEW: 카테고리별 통계
                "payload_category_breakdown": category_stats,
            },
            # ✨ NEW: 개선된 취약점 리스트
            "vulnerabilities": vulnerabilities_list,
            # ✨ NEW: 전체 요약
            "executive_summary": {
                "korean": f"{len(vulnerabilities_list)}개의 고유한 XSS 취약점이 발견되었습니다. 총 {successful_payloads_total}개의 페이로드가 성공했으며, 이는 입력 검증이 부족함을 나타냅니다.",
                "english": f"Found {len(vulnerabilities_list)} unique XSS vulnerabilities. {successful_payloads_total} payloads succeeded, indicating insufficient input validation.",
            },
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        }

        # JSON 저장
        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(report, f, ensure_ascii=False, indent=2)

        print(f"\n[*] ✨ report exported to: {output_path}")
        print(f"[*] Unique vulnerabilities: {len(vulnerabilities_list)}")
        print(f"[*] Total payloads tested: {total_tests_attempted}")


# ============================================================
# Interactive launcher (범용 버전)
# ============================================================
if __name__ == "__main__":
    import os
    import sys

    print("\n" + "=" * 70)
    print("s2n-xss : XSS Vulnerability Scanner")
    print("=" * 70)
    print("\n✨ Features:")
    print("  ✓ 3 XSS types: Reflected, Stored, DOM")
    print("  ✓ Context-aware payload selection")
    print("  ✓ Korean encoding detection (EUC-KR, fullwidth)")
    print("  ✓ Developer-friendly reports (KR/EN)")
    print("  ✓ Interactive mode")
    print("  ✓ Auto input detection")
    print()

    # 페이로드 파일 경로
    default_payload = "xss_payloads.json"
    if not os.path.exists(default_payload):
        default_payload = os.path.join(os.path.dirname(__file__), "xss_payloads.json")

    # 1. Target URL 입력
    print("=" * 70)
    print("Step 1: Target URL")
    print("=" * 70)
    try:
        target_url = input("\n[>] Enter target URL: ").strip()
    except (KeyboardInterrupt, EOFError):
        print("\n\nAborted by user.")
        sys.exit(0)

    if not target_url:
        print("\n[!] No URL provided. Exiting.")
        sys.exit(0)

    # URL 파싱하여 파라미터 확인
    parsed = urlparse(target_url)
    has_params = bool(parsed.query)

    # 2. 인증 쿠키 입력 (필수)
    print("\n" + "=" * 70)
    print("Step 2: Authentication (Required)")
    print("=" * 70)

    is_dvwa = "dvwa" in target_url.lower()

    if is_dvwa:
        print("\n[*] DVWA detected!")
        print("\nTo get cookies:")
        print("  1. Login to DVWA (admin/password)")
        print("  2. F12 → Application → Cookies")
        print("  3. Copy PHPSESSID value")

    print("\n[*] Enter PHPSESSID for authentication")
    phpsessid = input("[>] PHPSESSID: ").strip()

    cookies = None
    if phpsessid:
        cookies = {"PHPSESSID": phpsessid}

        if is_dvwa:
            security = (
                input("[>] Security level (low/medium/high, default=low): ")
                .strip()
                .lower()
            )
            cookies["security"] = (
                security if security in ["low", "medium", "high"] else "low"
            )

        print(f"\n[+] Cookies configured: {list(cookies.keys())}")
    else:
        print(
            "[!] Warning: No PHPSESSID provided. Some targets may require authentication."
        )

    # 자동 스캔 모드 활성화 (필수)
    auto_detect = True
    print(f"[+] Scan Mode: AUTO (automatic input point detection enabled)")

    if not has_params:
        print("[*] No parameters in URL - will auto-detect forms and parameters")

    # 3. 스캔 강도
    print("\n" + "=" * 70)
    print("Step 3: Scan Intensity")
    print("=" * 70)

    print("\n[?] Select intensity:")
    print("  1 - Basic      (~10 payloads)")
    print("  2 - Moderate   (~30 payloads) [Recommended]")
    print("  3 - Aggressive (50+ payloads)")
    intensity_input = input("[>] [1-3, default=2]: ").strip()

    if intensity_input in ["1", "2", "3"]:
        intensity = int(intensity_input)
    else:
        intensity = 2

    print(f"[+] Intensity: {intensity}/3")

    # 4. 스캐너 초기화
    print("\n" + "=" * 70)
    print("Initializing Scanner")
    print("=" * 70)

    if not os.path.exists(default_payload):
        print(f"\n[ERROR] Payload file not found: {default_payload}")
        print("\nPlease ensure xss_payloads.json is in the same directory")
        sys.exit(1)

    try:
        scanner = S2NXSSPlugin(
            payloads_path=default_payload,
            cookies=cookies,
            timeout=10,
            auto_detect=auto_detect,
        )
    except Exception as e:
        print(f"\n[ERROR] Failed to initialize: {e}")
        sys.exit(1)

    # 5. 스캔 실행
    print("\n" + "=" * 70)
    print("Starting Scan")
    print("=" * 70)

    try:
        start_time = time.time()
        results = scanner.scan(
            target_url=target_url, params=None, method="GET", intensity=intensity
        )
        elapsed = time.time() - start_time
    except KeyboardInterrupt:
        print("\n\n[!] Scan interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[ERROR] Scan failed: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)

    # 6. 결과 출력
    print("\n" + "=" * 70)
    print("SCAN RESULTS")
    print("=" * 70)
    print(f"\nScan completed in {elapsed:.1f} seconds")
    print(f"Target: {target_url}")
    print(f"Total vulnerabilities found: {len(results)}")

    if not results:
        print("\n✅ No XSS vulnerabilities detected")
        print("\nPossible reasons:")
        print("  - Target is properly secured")
        print("  - No input points found (check authentication)")
        print("  - Filters are blocking payloads")
    else:
        print(f"\n⚠️  Found {len(results)} XSS vulnerability(ies)!\n")

        # ✨ NEW: 그룹핑된 통계 표시
        unique_locations = len(scanner.grouped_vulnerabilities)
        print(f"Unique vulnerable locations: {unique_locations}")

        # 심각도별 분류
        severity_count = {}
        for vuln in results:
            sev = vuln["severity"]
            severity_count[sev] = severity_count.get(sev, 0) + 1

        print("\nBy severity:")
        for sev in ["CRITICAL", "HIGH", "MEDIUM", "LOW"]:
            count = severity_count.get(sev, 0)
            if count > 0:
                print(f"  {sev}: {count}")

        # XSS 타입별 분류
        type_count = {}
        for vuln in results:
            vtype = vuln.get("xss_type", "Unknown")
            type_count[vtype] = type_count.get(vtype, 0) + 1

        print("\nBy XSS type:")
        for vtype, count in type_count.items():
            print(f"  {vtype}: {count}")

        # ✨ NEW: 그룹핑된 취약점 요약
        print("\n" + "-" * 70)
        print("Grouped Vulnerabilities:")
        print("-" * 70)

        for i, (location_key, vuln_data) in enumerate(
            scanner.grouped_vulnerabilities.items(), 1
        ):
            print(f"\n[{i}] {vuln_data['location']['url']}")
            print(f"    Parameter: {vuln_data['location']['parameter']}")
            print(f"    Method: {vuln_data['location']['method']}")
            print(f"    XSS Type: {vuln_data['xss_type']}")
            print(f"    Successful payloads: {len(vuln_data['successful_payloads'])}")

            # 카테고리별 분류
            categories = {}
            for p in vuln_data["successful_payloads"]:
                cat = p["category_ko"]
                categories[cat] = categories.get(cat, 0) + 1

            print(
                f"    Categories: {', '.join(f'{k}({v})' for k, v in categories.items())}"
            )

        # 리포트 저장
        print("\n" + "=" * 70)
        print("Saving Report")
        print("=" * 70)

        try:
            scanner.export_report(None)
        except Exception as e:
            print(f"\n[!] Failed to save report: {e}")

    print("\n" + "=" * 70)
    print("Scan Complete")
    print("=" * 70)
    print()

    sys.exit(0 if not results else len(results))
