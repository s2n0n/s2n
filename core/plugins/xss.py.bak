"""
s2n-xss: XSS Vulnerability Scanner
Developer-friendly XSS detection optimized for Korean web applications

Features:
- Context-aware payload selection
- Korean encoding issue detection (UTF-8, EUC-KR, fullwidth chars)
- Developer-friendly detailed reports with fix recommendations
- Interactive scanning mode
- Lightweight and CI/CD friendly
"""

import json
import requests
import re
from urllib.parse import urlencode, urlparse, parse_qs
from typing import Dict, List, Tuple, Optional
from html.parser import HTMLParser
import time


class S2NXSSPlugin:
    """
    s2n-xss: XSS 취약점 자동 탐지 스캐너

    Attributes:
        payloads (dict): xss_payloads.json에서 로드한 페이로드
        interactive (bool): Interactive mode 활성화 여부
        results (list): 탐지된 취약점 리스트
        session (requests.Session): HTTP 세션
    """

    # 심각도 레벨 정의
    SEVERITY_CRITICAL = "CRITICAL"
    SEVERITY_HIGH = "HIGH"
    SEVERITY_MEDIUM = "MEDIUM"
    SEVERITY_LOW = "LOW"

    # 컨텍스트 타입
    CONTEXT_HTML = "html"
    CONTEXT_ATTRIBUTE = "attribute"
    CONTEXT_JAVASCRIPT = "javascript"
    CONTEXT_URL = "url"

    def __init__(
        self,
        payloads_path: str = "payloads/xss_payloads.json",
        interactive: bool = False,
        timeout: int = 10,
        cookies: Optional[Dict] = None,
    ):
        """
        XSS 스캐너 초기화

        Args:
            payloads_path: 페이로드 JSON 파일 경로
            interactive: Interactive mode 활성화
            timeout: HTTP 요청 타임아웃 (초)
            cookies: 요청에 사용할 쿠키 딕셔너리
        """
        self.payloads = self._load_payloads(payloads_path)
        self.interactive = interactive
        self.timeout = timeout
        self.results = []
        self.session = requests.Session()
        self.session.headers.update(
            {
                "User-Agent": "s2n-xss/1.0.0 (Security Scanner)",
                "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            }
        )

        # 쿠키 설정 추가
        if cookies:
            for key, value in cookies.items():
                self.session.cookies.set(key, value)
            print(f"[*] Cookie set: {list(cookies.keys())}")

        print(f"[*] s2n-xss v{self.payloads['metadata']['version']} initialized")
        print(f"[*] Loaded {self.payloads['metadata']['total_payloads']} payloads")
        if interactive:
            print("[*] Interactive mode: ENABLED")

    def _load_payloads(self, path: str) -> dict:
        """페이로드 JSON 파일 로드"""
        try:
            with open(path, "r", encoding="utf-8") as f:
                return json.load(f)
        except FileNotFoundError:
            raise FileNotFoundError(f"Payload file not found: {path}")
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON format in payload file: {e}")

    def scan(
        self,
        target_url: str,
        params: Optional[Dict] = None,
        method: str = "GET",
        intensity: int = 2,
    ) -> List[Dict]:
        """
        XSS 취약점 스캔 메인 함수

        Args:
            target_url: 대상 URL
            params: 테스트할 파라미터 딕셔너리 (None일 경우 URL에서 추출)
            method: HTTP 메소드 ('GET' 또는 'POST')
            intensity: 스캔 강도 (1=Basic, 2=Moderate, 3=Aggressive)

        Returns:
            탐지된 취약점 리스트
        """
        print(f"\n[*] Starting s2n-xss scan on: {target_url}")
        print(f"[*] Method: {method} | Intensity: {intensity}/3")

        # URL에서 파라미터 추출 (params가 None인 경우)
        if params is None:
            parsed = urlparse(target_url)
            params = parse_qs(parsed.query)
            # query string이 없으면 빈 dict
            if not params:
                params = {}

        if not params:
            print("[!] No parameters found to test")
            return self.results

        # Interactive mode: 파라미터 선택
        if self.interactive:
            params = self._interactive_param_selection(params)

        # 각 파라미터 테스트
        for param_name, param_value in params.items():
            print(f"\n[*] Testing parameter: {param_name}")
            self._test_parameter(target_url, param_name, param_value, method, intensity)

        # 한국어 인코딩 이슈 체크
        if self.interactive:
            if self._interactive_prompt(
                "Check for Korean encoding issues? (UTF-8/EUC-KR)"
            ):
                self._check_korean_encoding_issues(target_url, params, method)
        else:
            self._check_korean_encoding_issues(target_url, params, method)

        print(f"\n[*] Scan completed. Found {len(self.results)} vulnerabilities")
        return self.results

    def _test_parameter(
        self, url: str, param_name: str, param_value: any, method: str, intensity: int
    ):
        """
        개별 파라미터 XSS 테스트

        Args:
            url: 대상 URL
            param_name: 파라미터 이름
            param_value: 파라미터 원본 값
            method: HTTP 메소드
            intensity: 스캔 강도
        """
        # 1단계: 컨텍스트 감지
        marker = "s2n_xss_marker_" + str(int(time.time()))
        context = self._detect_context(url, param_name, marker, method)
        print(f"  [+] Detected context: {context}")

        # 2단계: 컨텍스트별 페이로드 선택
        payloads_to_test = self._select_payloads(context, intensity)
        print(f"  [+] Testing {len(payloads_to_test)} payloads...")

        # 3단계: 페이로드 테스트
        for i, payload in enumerate(payloads_to_test, 1):
            if self._test_single_payload(url, param_name, payload, method):
                print(f"  [!] VULNERABILITY FOUND with payload #{i}")
                # 취약점 상세 리포트 생성
                finding = self._generate_detailed_report(
                    url, param_name, payload, method, context
                )
                self.results.append(finding)

                # Interactive mode: 계속할지 확인
                if self.interactive:
                    if not self._interactive_prompt("Continue testing this parameter?"):
                        break

    def _detect_context(
        self, url: str, param_name: str, marker: str, method: str
    ) -> str:
        """
        주입된 마커가 렌더링되는 HTML 컨텍스트 감지

        Args:
            url: 대상 URL
            param_name: 파라미터 이름
            marker: 컨텍스트 감지용 마커 문자열
            method: HTTP 메소드

        Returns:
            감지된 컨텍스트 타입 ('html', 'attribute', 'javascript', 'url')
        """
        try:
            # 마커 주입
            response = self._send_request(url, {param_name: marker}, method)

            if not response:
                return self.CONTEXT_HTML  # 기본값

            html = response.text

            # 마커가 응답에 있는지 확인
            if marker not in html:
                return self.CONTEXT_HTML

            # 컨텍스트 분석
            # JavaScript 컨텍스트 체크 (<script> 태그 내부 또는 이벤트 핸들러)
            js_pattern = rf"<script[^>]*>.*?{re.escape(marker)}.*?</script>"
            if re.search(js_pattern, html, re.DOTALL | re.IGNORECASE):
                return self.CONTEXT_JAVASCRIPT

            # 속성 컨텍스트 체크 (HTML 태그 속성 내부)
            attr_pattern = (
                rf'<[^>]+\s+\w+=["\']?[^"\']*{re.escape(marker)}[^"\']*["\']?[^>]*>'
            )
            if re.search(attr_pattern, html, re.IGNORECASE):
                return self.CONTEXT_ATTRIBUTE

            # URL 컨텍스트 체크 (href, src 속성)
            url_pattern = rf'(?:href|src)=["\']?[^"\']*{re.escape(marker)}[^"\']*["\']?'
            if re.search(url_pattern, html, re.IGNORECASE):
                return self.CONTEXT_URL

            # 기본: HTML 컨텍스트
            return self.CONTEXT_HTML

        except Exception as e:
            print(f"  [!] Error detecting context: {e}")
            return self.CONTEXT_HTML

    def _select_payloads(self, context: str, intensity: int) -> List[str]:
        """
        컨텍스트와 강도에 맞는 페이로드 선택

        Args:
            context: 감지된 컨텍스트
            intensity: 스캔 강도 (1=10개, 2=30개, 3=모두)

        Returns:
            선택된 페이로드 리스트
        """
        selected = []

        # 컨텍스트별 기본 페이로드
        if context == self.CONTEXT_HTML:
            selected.extend(self.payloads["payloads"]["html_context"]["basic"])
            if intensity >= 2:
                selected.extend(
                    self.payloads["payloads"]["html_context"]["korean_specific"]
                )
            if intensity >= 3:
                selected.extend(self.payloads["payloads"]["html_context"]["html5"])

        elif context == self.CONTEXT_ATTRIBUTE:
            selected.extend(
                self.payloads["payloads"]["attribute_context"]["double_quote"]
            )
            if intensity >= 2:
                selected.extend(
                    self.payloads["payloads"]["attribute_context"]["single_quote"]
                )
            if intensity >= 3:
                selected.extend(
                    self.payloads["payloads"]["attribute_context"]["no_quote"]
                )
                selected.extend(
                    self.payloads["payloads"]["attribute_context"]["href_src"]
                )

        elif context == self.CONTEXT_JAVASCRIPT:
            selected.extend(
                self.payloads["payloads"]["javascript_context"]["string_escape"]
            )
            if intensity >= 2:
                selected.extend(
                    self.payloads["payloads"]["javascript_context"][
                        "variable_injection"
                    ]
                )

        elif context == self.CONTEXT_URL:
            selected.extend(self.payloads["payloads"]["url_context"])

        # 필터 우회 페이로드 추가
        if intensity >= 2:
            selected.extend(self.payloads["filter_bypass"]["encoding"][:5])
            selected.extend(self.payloads["filter_bypass"]["obfuscation"][:3])

        if intensity >= 3:
            selected.extend(self.payloads["filter_bypass"]["space_bypass"])
            selected.extend(self.payloads["filter_bypass"]["comment_bypass"])

        # 강도에 따른 제한
        if intensity == 1:
            return selected[:10]
        elif intensity == 2:
            return selected[:30]
        else:
            return selected

    def _test_single_payload(
        self, url: str, param_name: str, payload: str, method: str
    ) -> bool:
        """
        단일 페이로드로 XSS 테스트

        Args:
            url: 대상 URL
            param_name: 파라미터 이름
            payload: 테스트 페이로드
            method: HTTP 메소드

        Returns:
            취약점 발견 여부 (True/False)
        """
        try:
            response = self._send_request(url, {param_name: payload}, method)

            if not response:
                return False

            # XSS 성공 여부 확인
            # 1. 페이로드가 그대로 반영되었는지 (HTML 이스케이프 안됨)
            if payload in response.text:
                return True

            # 2. script 태그가 실행 가능한 형태로 존재하는지
            if "<script>" in payload.lower() and "<script>" in response.text.lower():
                return True

            # 3. 이벤트 핸들러가 있는지
            event_handlers = ["onload", "onerror", "onclick", "onfocus", "onmouseover"]
            for handler in event_handlers:
                if handler in payload.lower() and handler in response.text.lower():
                    return True

            return False

        except Exception as e:
            print(f"  [!] Error testing payload: {e}")
            return False

    def _check_korean_encoding_issues(self, url: str, params: Dict, method: str):
        """
        한국어 웹 환경 특화 인코딩 이슈 체크

        - EUC-KR 인코딩 취약점
        - 전각 문자 우회 (＜script＞)
        - 유니코드 정규화 이슈
        """
        print("\n[*] Checking Korean-specific encoding issues...")

        korean_payloads = self.payloads["korean_encoding_specific"]

        for param_name in params.keys():
            # EUC-KR 테스트
            for payload in korean_payloads["euc_kr_bypass"]:
                if self._test_single_payload(url, param_name, payload, method):
                    print(
                        f"  [!] EUC-KR encoding vulnerability found in '{param_name}'"
                    )
                    finding = self._generate_detailed_report(
                        url, param_name, payload, method, "korean_euc_kr"
                    )
                    self.results.append(finding)

            # 전각 문자 테스트
            for payload in korean_payloads["fullwidth_chars"]:
                if self._test_single_payload(url, param_name, payload, method):
                    print(f"  [!] Fullwidth character bypass found in '{param_name}'")
                    finding = self._generate_detailed_report(
                        url, param_name, payload, method, "korean_fullwidth"
                    )
                    self.results.append(finding)

    def _send_request(
        self, url: str, params: Dict, method: str
    ) -> Optional[requests.Response]:
        """
        HTTP 요청 전송

        Args:
            url: 대상 URL
            params: 파라미터
            method: HTTP 메소드

        Returns:
            응답 객체 또는 None
        """
        try:
            if method.upper() == "GET":
                response = self.session.get(url, params=params, timeout=self.timeout)
            elif method.upper() == "POST":
                response = self.session.post(url, data=params, timeout=self.timeout)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")

            return response

        except requests.RequestException as e:
            print(f"  [!] Request error: {e}")
            return None

    def _generate_detailed_report(
        self, url: str, param_name: str, payload: str, method: str, context: str
    ) -> Dict:
        """
        개발자 친화적 상세 리포트 생성

        Returns:
            취약점 상세 정보 딕셔너리 (한영 병기)
        """
        # CVSS 점수 계산 (간단한 버전)
        cvss_score = self._calculate_cvss(context)
        severity = self._get_severity(cvss_score)

        report = {
            "scanner": "s2n-xss",
            "vulnerability_type": "Cross-Site Scripting (XSS)",
            "vulnerability_type_ko": "크로스 사이트 스크립팅 (XSS)",
            "severity": severity,
            "cvss_score": cvss_score,
            "location": {"url": url, "parameter": param_name, "method": method},
            "evidence": {
                "payload_used": payload,
                "context_detected": context,
                "injection_point": f"{method} {url}?{param_name}={payload}",
            },
            "description": {
                "korean": f"'{param_name}' 파라미터에서 XSS 취약점이 발견되었습니다. "
                f"공격자가 악의적인 스크립트를 주입하여 사용자의 세션을 탈취하거나 "
                f"민감한 정보를 유출할 수 있습니다.",
                "english": f"XSS vulnerability found in parameter '{param_name}'. "
                f"Attackers can inject malicious scripts to steal user sessions "
                f"or exfiltrate sensitive information.",
            },
            "impact": {
                "korean": [
                    "사용자 세션 쿠키 탈취",
                    "사용자 계정 권한으로 악의적 행위 수행",
                    "피싱 페이지로 리다이렉트",
                    "사용자 입력 정보 탈취",
                ],
                "english": [
                    "Session cookie theft",
                    "Unauthorized actions with user privileges",
                    "Redirection to phishing pages",
                    "User input data exfiltration",
                ],
            },
            "fix_recommendation": {
                "korean": "모든 사용자 입력값을 출력하기 전 HTML 이스케이프 처리가 필요합니다. "
                "또한 Content Security Policy (CSP) 헤더를 설정하여 XSS 공격을 방어하세요.",
                "english": "All user inputs must be HTML-escaped before output. "
                "Additionally, implement Content Security Policy (CSP) headers.",
            },
            "code_example": {
                "vulnerable_php": f"echo $_GET['{param_name}'];  // VULNERABLE",
                "fixed_php": f"echo htmlspecialchars($_GET['{param_name}'], ENT_QUOTES, 'UTF-8');  // SECURE",
                "vulnerable_python": f"return user_input  # VULNERABLE",
                "fixed_python": f"from html import escape\nreturn escape(user_input)  # SECURE",
                "vulnerable_javascript": f"element.innerHTML = userInput;  // VULNERABLE",
                "fixed_javascript": f"element.textContent = userInput;  // SECURE",
                "csp_header": "Content-Security-Policy: default-src 'self'; script-src 'self'",
            },
            "references": [
                "https://owasp.org/www-community/attacks/xss/",
                "https://portswigger.net/web-security/cross-site-scripting",
                "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html",
                "https://developer.mozilla.org/ko/docs/Web/Security/Types_of_attacks#%ED%81%AC%EB%A1%9C%EC%8A%A4_%EC%82%AC%EC%9D%B4%ED%8A%B8_%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85_xss",
            ],
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        }

        return report

    def _calculate_cvss(self, context: str) -> float:
        """컨텍스트 기반 간단한 CVSS 점수 계산"""
        base_scores = {
            self.CONTEXT_HTML: 7.5,
            self.CONTEXT_ATTRIBUTE: 7.0,
            self.CONTEXT_JAVASCRIPT: 8.0,
            self.CONTEXT_URL: 6.5,
            "korean_euc_kr": 7.5,
            "korean_fullwidth": 7.5,
        }
        return base_scores.get(context, 7.0)

    def _get_severity(self, cvss_score: float) -> str:
        """CVSS 점수로부터 심각도 레벨 결정"""
        if cvss_score >= 9.0:
            return self.SEVERITY_CRITICAL
        elif cvss_score >= 7.0:
            return self.SEVERITY_HIGH
        elif cvss_score >= 4.0:
            return self.SEVERITY_MEDIUM
        else:
            return self.SEVERITY_LOW

    def _interactive_prompt(self, message: str) -> bool:
        """Interactive mode용 사용자 확인 프롬프트"""
        if not self.interactive:
            return True

        response = input(f"[?] {message} [y/n]: ").strip().lower()
        return response in ["y", "yes", "ㅛ"]  # 한글 키보드 오타 대응

    def _interactive_param_selection(self, params: Dict) -> Dict:
        """Interactive mode: 테스트할 파라미터 선택"""
        print("\n[?] Found parameters:")
        for i, (key, value) in enumerate(params.items(), 1):
            print(f"  {i}. {key} = {value}")

        print("\n[?] Test options:")
        print("  1. Test all parameters")
        print("  2. Select specific parameters")

        choice = input("[>] Choice [1-2]: ").strip()

        if choice == "2":
            selected = {}
            for key in params.keys():
                if self._interactive_prompt(f"Test parameter '{key}'?"):
                    selected[key] = params[key]
            return selected

        return params

    def scan_interactive(self, target_url: str) -> List[Dict]:
        """Interactive mode로 스캔 실행"""
        print("\n" + "=" * 60)
        print("s2n-xss Interactive Scanning Mode")
        print("=" * 60)
        print(f"Target: {target_url}\n")

        # HTTP 메소드 선택
        print("[?] Select HTTP method:")
        print("  1. GET")
        print("  2. POST")
        method_choice = input("[>] Choice [1-2]: ").strip()
        method = "POST" if method_choice == "2" else "GET"

        # 스캔 강도 선택
        print("\n[?] Select scan intensity:")
        print("  1. Basic (fast, ~10 payloads per parameter)")
        print("  2. Moderate (balanced, ~30 payloads per parameter)")
        print("  3. Aggressive (thorough, 50+ payloads per parameter)")
        intensity_choice = input("[>] Choice [1-3]: ").strip()
        intensity = int(intensity_choice) if intensity_choice in ["1", "2", "3"] else 2

        # 스캔 실행
        return self.scan(target_url, method=method, intensity=intensity)

    def export_report(self, output_path: str = "s2n_xss_report.json"):
        """스캔 결과를 JSON 파일로 내보내기"""
        report = {
            "scanner": "s2n-xss",
            "version": self.payloads["metadata"]["version"],
            "scan_summary": {
                "total_vulnerabilities": len(self.results),
                "severity_breakdown": {
                    "CRITICAL": sum(
                        1 for r in self.results if r["severity"] == "CRITICAL"
                    ),
                    "HIGH": sum(1 for r in self.results if r["severity"] == "HIGH"),
                    "MEDIUM": sum(1 for r in self.results if r["severity"] == "MEDIUM"),
                    "LOW": sum(1 for r in self.results if r["severity"] == "LOW"),
                },
            },
            "vulnerabilities": self.results,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        }

        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(report, f, ensure_ascii=False, indent=2)

        print(f"\n[*] Report exported to: {output_path}")


# ----------------------------
# Interactive launcher
# ----------------------------
if __name__ == "__main__":
    import os
    import sys
    import time
    import json

    # 기본 페이로드 파일: xss.py와 같은 디렉터리에 있는 xss_payloads.json
    default_payload = os.path.join(os.path.dirname(__file__), "xss_payloads.json")

    print("s2n-xss — interactive launcher (uses S2NXSSPlugin)")
    print("Enter the target URL to scan (example):")
    print("http://localhost/dvwa/vulnerabilities/xss_r/?name=test")
    try:
        target_url = input("Target URL (blank to exit): ").strip()
    except (KeyboardInterrupt, EOFError):
        print("\nAborted.")
        sys.exit(0)

    if not target_url:
        print("No target URL provided. Exiting.")
        sys.exit(0)

    # 페이로드 파일 존재 확인
    payloads_path = default_payload
    if not os.path.exists(payloads_path):
        print(f"[ERROR] Payload file not found at expected path: {payloads_path}")
        print(
            "Place xss_payloads.json next to xss.py or change the path in the script."
        )
        sys.exit(1)

    # S2NXSSPlugin 인스턴스 생성 (생성자 시 payloads_path 인자 지원하면 전달)
    try:
        # 강제로 payloads_path를 전달 — 파일 위치를 정확히 지정해서 실패 방지
        try:
            scanner = S2NXSSPlugin(payloads_path=payloads_path)
        except TypeError:
            # 생성자가 payloads_path 인자를 안 받으면 빈 생성자로 시도
            scanner = S2NXSSPlugin()
    except Exception as e:
        print("[ERROR] Could not instantiate S2NXSSPlugin:", e)
        sys.exit(1)

    # 호환성: 인스턴스에 payloads_path 속성이 있으면 설정
    if hasattr(scanner, "payloads_path"):
        try:
            scanner.payloads_path = payloads_path
        except Exception:
            pass

    # (선택) 디버그 기본값: scanner.debug 존재하면 False 유지. 필요시 편집으로 True 전환.
    if hasattr(scanner, "debug"):
        scanner.debug = True

    # 실제 스캔 실행: scan(target) 우선, 없으면 run(target)
    try:
        print(f"\n[*] s2n-xss scanning {target_url} ...")
        start = time.time()
        if hasattr(scanner, "scan"):
            results = scanner.scan(target_url)
        elif hasattr(scanner, "run"):
            results = scanner.run(target_url)
        else:
            raise RuntimeError(
                "S2NXSSPlugin instance has neither scan() nor run() method."
            )
        elapsed = time.time() - start
    except Exception as e:
        print("[ERROR] Scan failed:", e)
        sys.exit(1)

    # 간단 요약 출력
    total = 0
    try:
        if isinstance(results, dict):
            findings = (
                results.get("findings")
                or results.get("vulnerabilities")
                or results.get("results")
                or []
            )
            total = len(findings)
        elif isinstance(results, list):
            total = len(results)
    except Exception:
        total = 0

    print(
        f"\n[*] Scan finished in {elapsed:.1f}s — Found {total} vulnerabilities (summary)."
    )

    # 리포트 파일 내보내기: export_report()가 있으면 사용, 없으면 results를 JSON으로 저장
    try:
        if hasattr(scanner, "export_report"):
            outpath = "s2n_xss_report.json"
            scanner.export_report(outpath)
            print(f"[*] Report exported to: {outpath}")
        else:
            if isinstance(results, (dict, list)):
                outpath = "s2n_xss_report.json"
                with open(outpath, "w", encoding="utf-8") as f:
                    json.dump(results, f, ensure_ascii=False, indent=2)
                print(f"[*] Report saved to: {outpath}")
    except Exception as e:
        print("[WARN] Could not export report automatically:", e)

    print("Done.")
